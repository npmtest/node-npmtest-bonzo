{"/home/travis/build/npmtest/node-npmtest-bonzo/test.js":"/* istanbul instrument in package npmtest_bonzo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bonzo/lib.npmtest_bonzo.js":"/* istanbul instrument in package npmtest_bonzo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_bonzo = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_bonzo = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-bonzo/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-bonzo && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_bonzo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_bonzo\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_bonzo.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_bonzo.rollup.js'] =\n            local.assetsDict['/assets.npmtest_bonzo.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_bonzo.__dirname + '/lib.npmtest_bonzo.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bonzo/node_modules/bonzo/bonzo.js":"/*!\n  * Bonzo: DOM Utility (c) Dustin Diaz 2012\n  * https://github.com/ded/bonzo\n  * License MIT\n  */\n(function (name, context, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (typeof define == 'function' && define.amd) define(definition)\n  else context[name] = definition()\n})('bonzo', this, function() {\n  var win = window\n    , doc = win.document\n    , html = doc.documentElement\n    , parentNode = 'parentNode'\n    , specialAttributes = /^(checked|value|selected|disabled)$/i\n      // tags that we have trouble inserting *into*\n    , specialTags = /^(select|fieldset|table|tbody|tfoot|td|tr|colgroup)$/i\n    , simpleScriptTagRe = /\\s*<script +src=['\"]([^'\"]+)['\"]>/\n    , table = ['<table>', '</table>', 1]\n    , td = ['<table><tbody><tr>', '</tr></tbody></table>', 3]\n    , option = ['<select>', '</select>', 1]\n    , noscope = ['_', '', 0, 1]\n    , tagMap = { // tags that we have trouble *inserting*\n          thead: table, tbody: table, tfoot: table, colgroup: table, caption: table\n        , tr: ['<table><tbody>', '</tbody></table>', 2]\n        , th: td , td: td\n        , col: ['<table><colgroup>', '</colgroup></table>', 2]\n        , fieldset: ['<form>', '</form>', 1]\n        , legend: ['<form><fieldset>', '</fieldset></form>', 2]\n        , option: option, optgroup: option\n        , script: noscope, style: noscope, link: noscope, param: noscope, base: noscope\n      }\n    , stateAttributes = /^(checked|selected|disabled)$/\n    , hasClass, addClass, removeClass\n    , uidMap = {}\n    , uuids = 0\n    , digit = /^-?[\\d\\.]+$/\n    , dattr = /^data-(.+)$/\n    , px = 'px'\n    , setAttribute = 'setAttribute'\n    , getAttribute = 'getAttribute'\n    , features = function() {\n        var e = doc.createElement('p')\n        return {\n          transform: function () {\n            var props = ['transform', 'webkitTransform', 'MozTransform', 'OTransform', 'msTransform'], i\n            for (i = 0; i < props.length; i++) {\n              if (props[i] in e.style) return props[i]\n            }\n          }()\n        , classList: 'classList' in e\n        }\n      }()\n    , whitespaceRegex = /\\s+/\n    , toString = String.prototype.toString\n    , unitless = { lineHeight: 1, zoom: 1, zIndex: 1, opacity: 1, boxFlex: 1, WebkitBoxFlex: 1, MozBoxFlex: 1 }\n    , query = doc.querySelectorAll && function (selector) { return doc.querySelectorAll(selector) }\n\n\n  function getStyle(el, property) {\n    var value = null\n      , computed = doc.defaultView.getComputedStyle(el, '')\n    computed && (value = computed[property])\n    return el.style[property] || value\n  }\n\n\n  function isNode(node) {\n    return node && node.nodeName && (node.nodeType == 1 || node.nodeType == 11)\n  }\n\n\n  function normalize(node, host, clone) {\n    var i, l, ret\n    if (typeof node == 'string') return bonzo.create(node)\n    if (isNode(node)) node = [ node ]\n    if (clone) {\n      ret = [] // don't change original array\n      for (i = 0, l = node.length; i < l; i++) ret[i] = cloneNode(host, node[i])\n      return ret\n    }\n    return node\n  }\n\n  /**\n   * @param {string} c a class name to test\n   * @return {boolean}\n   */\n  function classReg(c) {\n    return new RegExp('(^|\\\\s+)' + c + '(\\\\s+|$)')\n  }\n\n\n  /**\n   * @param {Bonzo|Array} ar\n   * @param {function(Object, number, (Bonzo|Array))} fn\n   * @param {Object=} opt_scope\n   * @param {boolean=} opt_rev\n   * @return {Bonzo|Array}\n   */\n  function each(ar, fn, opt_scope, opt_rev) {\n    var ind, i = 0, l = ar.length\n    for (; i < l; i++) {\n      ind = opt_rev ? ar.length - i - 1 : i\n      fn.call(opt_scope || ar[ind], ar[ind], ind, ar)\n    }\n    return ar\n  }\n\n\n  /**\n   * @param {Bonzo|Array} ar\n   * @param {function(Object, number, (Bonzo|Array))} fn\n   * @param {Object=} opt_scope\n   * @return {Bonzo|Array}\n   */\n  function deepEach(ar, fn, opt_scope) {\n    for (var i = 0, l = ar.length; i < l; i++) {\n      if (isNode(ar[i])) {\n        deepEach(ar[i].childNodes, fn, opt_scope)\n        fn.call(opt_scope || ar[i], ar[i], i, ar)\n      }\n    }\n    return ar\n  }\n\n\n  /**\n   * @param {string} s\n   * @return {string}\n   */\n  function camelize(s) {\n    return s.replace(/-(.)/g, function (m, m1) {\n      return m1.toUpperCase()\n    })\n  }\n\n\n  /**\n   * @param {string} s\n   * @return {string}\n   */\n  function decamelize(s) {\n    return s ? s.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() : s\n  }\n\n\n  /**\n   * @param {Element} el\n   * @return {*}\n   */\n  function data(el) {\n    el[getAttribute]('data-node-uid') || el[setAttribute]('data-node-uid', ++uuids)\n    var uid = el[getAttribute]('data-node-uid')\n    return uidMap[uid] || (uidMap[uid] = {})\n  }\n\n\n  /**\n   * removes the data associated with an element\n   * @param {Element} el\n   */\n  function clearData(el) {\n    var uid = el[getAttribute]('data-node-uid')\n    if (uid) delete uidMap[uid]\n  }\n\n\n  function dataValue(d) {\n    var f\n    try {\n      return (d === null || d === undefined) ? undefined :\n        d === 'true' ? true :\n          d === 'false' ? false :\n            d === 'null' ? null :\n              (f = parseFloat(d)) == d ? f : d;\n    } catch(e) {}\n    return undefined\n  }\n\n\n  /**\n   * @param {Bonzo|Array} ar\n   * @param {function(Object, number, (Bonzo|Array))} fn\n   * @param {Object=} opt_scope\n   * @return {boolean} whether `some`thing was found\n   */\n  function some(ar, fn, opt_scope) {\n    for (var i = 0, j = ar.length; i < j; ++i) if (fn.call(opt_scope || null, ar[i], i, ar)) return true\n    return false\n  }\n\n\n  /**\n   * this could be a giant enum of CSS properties\n   * but in favor of file size sans-closure deadcode optimizations\n   * we're just asking for any ol string\n   * then it gets transformed into the appropriate style property for JS access\n   * @param {string} p\n   * @return {string}\n   */\n  function styleProperty(p) {\n      (p == 'transform' && (p = features.transform)) ||\n        (/^transform-?[Oo]rigin$/.test(p) && (p = features.transform + 'Origin'))\n      return p ? camelize(p) : null\n  }\n\n  // this insert method is intense\n  function insert(target, host, fn, rev) {\n    var i = 0, self = host || this, r = []\n      // target nodes could be a css selector if it's a string and a selector engine is present\n      // otherwise, just use target\n      , nodes = query && typeof target == 'string' && target.charAt(0) != '<' ? query(target) : target\n    // normalize each node in case it's still a string and we need to create nodes on the fly\n    each(normalize(nodes), function (t, j) {\n      each(self, function (el) {\n        fn(t, r[i++] = j > 0 ? cloneNode(self, el) : el)\n      }, null, rev)\n    }, this, rev)\n    self.length = i\n    each(r, function (e) {\n      self[--i] = e\n    }, null, !rev)\n    return self\n  }\n\n\n  /**\n   * sets an element to an explicit x/y position on the page\n   * @param {Element} el\n   * @param {?number} x\n   * @param {?number} y\n   */\n  function xy(el, x, y) {\n    var $el = bonzo(el)\n      , style = $el.css('position')\n      , offset = $el.offset()\n      , rel = 'relative'\n      , isRel = style == rel\n      , delta = [parseInt($el.css('left'), 10), parseInt($el.css('top'), 10)]\n\n    if (style == 'static') {\n      $el.css('position', rel)\n      style = rel\n    }\n\n    isNaN(delta[0]) && (delta[0] = isRel ? 0 : el.offsetLeft)\n    isNaN(delta[1]) && (delta[1] = isRel ? 0 : el.offsetTop)\n\n    x != null && (el.style.left = x - offset.left + delta[0] + px)\n    y != null && (el.style.top = y - offset.top + delta[1] + px)\n\n  }\n\n  // classList support for class management\n  // altho to be fair, the api sucks because it won't accept multiple classes at once\n  if (features.classList) {\n    hasClass = function (el, c) {\n      return el.classList.contains(c)\n    }\n    addClass = function (el, c) {\n      el.classList.add(c)\n    }\n    removeClass = function (el, c) {\n      el.classList.remove(c)\n    }\n  }\n  else {\n    hasClass = function (el, c) {\n      return classReg(c).test(el.className)\n    }\n    addClass = function (el, c) {\n      el.className = (el.className + ' ' + c).trim()\n    }\n    removeClass = function (el, c) {\n      el.className = (el.className.replace(classReg(c), ' ')).trim()\n    }\n  }\n\n\n  /**\n   * this allows method calling for setting values\n   *\n   * @example\n   * bonzo(elements).css('color', function (el) {\n   *   return el.getAttribute('data-original-color')\n   * })\n   *\n   * @param {Element} el\n   * @param {function (Element)|string} v\n   * @return {string}\n   */\n  function setter(el, v) {\n    return typeof v == 'function' ? v.call(el, el) : v\n  }\n\n  function scroll(x, y, type) {\n    var el = this[0]\n    if (!el) return this\n    if (x == null && y == null) {\n      return (isBody(el) ? getWindowScroll() : { x: el.scrollLeft, y: el.scrollTop })[type]\n    }\n    if (isBody(el)) {\n      win.scrollTo(x, y)\n    } else {\n      x != null && (el.scrollLeft = x)\n      y != null && (el.scrollTop = y)\n    }\n    return this\n  }\n\n  /**\n   * @constructor\n   * @param {Array.<Element>|Element|Node|string} elements\n   */\n  function Bonzo(elements) {\n    this.length = 0\n    if (elements) {\n      elements = typeof elements !== 'string' &&\n        !elements.nodeType &&\n        typeof elements.length !== 'undefined' ?\n          elements :\n          [elements]\n      this.length = elements.length\n      for (var i = 0; i < elements.length; i++) this[i] = elements[i]\n    }\n  }\n\n  Bonzo.prototype = {\n\n      /**\n       * @param {number} index\n       * @return {Element|Node}\n       */\n      get: function (index) {\n        return this[index] || null\n      }\n\n      // itetators\n      /**\n       * @param {function(Element|Node)} fn\n       * @param {Object=} opt_scope\n       * @return {Bonzo}\n       */\n    , each: function (fn, opt_scope) {\n        return each(this, fn, opt_scope)\n      }\n\n      /**\n       * @param {Function} fn\n       * @param {Object=} opt_scope\n       * @return {Bonzo}\n       */\n    , deepEach: function (fn, opt_scope) {\n        return deepEach(this, fn, opt_scope)\n      }\n\n\n      /**\n       * @param {Function} fn\n       * @param {Function=} opt_reject\n       * @return {Array}\n       */\n    , map: function (fn, opt_reject) {\n        var m = [], n, i\n        for (i = 0; i < this.length; i++) {\n          n = fn.call(this, this[i], i)\n          opt_reject ? (opt_reject(n) && m.push(n)) : m.push(n)\n        }\n        return m\n      }\n\n    // text and html inserters!\n\n    /**\n     * @param {string} h the HTML to insert\n     * @param {boolean=} opt_text whether to set or get text content\n     * @return {Bonzo|string}\n     */\n    , html: function (h, opt_text) {\n        var method = opt_text\n              ? 'textContent'\n              : 'innerHTML'\n          , that = this\n          , append = function (el, i) {\n              each(normalize(h, that, i), function (node) {\n                el.appendChild(node)\n              })\n            }\n          , updateElement = function (el, i) {\n              try {\n                if (opt_text || (typeof h == 'string' && !specialTags.test(el.tagName))) {\n                  return el[method] = h\n                }\n              } catch (e) {}\n              append(el, i)\n            }\n        return typeof h != 'undefined'\n          ? this.empty().each(updateElement)\n          : this[0] ? this[0][method] : ''\n      }\n\n      /**\n       * @param {string=} opt_text the text to set, otherwise this is a getter\n       * @return {Bonzo|string}\n       */\n    , text: function (opt_text) {\n        return this.html(opt_text, true)\n      }\n\n      // more related insertion methods\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , append: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el.appendChild(i)\n          })\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , prepend: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          var first = el.firstChild\n          each(normalize(node, that, i), function (i) {\n            el.insertBefore(i, first)\n          })\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , appendTo: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          t.appendChild(el)\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , prependTo: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          t.insertBefore(el, t.firstChild)\n        }, 1)\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , before: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el[parentNode].insertBefore(i, el)\n          })\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , after: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el[parentNode].insertBefore(i, el.nextSibling)\n          }, null, 1)\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , insertBefore: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          t[parentNode].insertBefore(el, t)\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , insertAfter: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          var sibling = t.nextSibling\n          sibling ?\n            t[parentNode].insertBefore(el, sibling) :\n            t[parentNode].appendChild(el)\n        }, 1)\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , replaceWith: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el[parentNode] && el[parentNode].replaceChild(i, el)\n          })\n        })\n      }\n\n      /**\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , clone: function (opt_host) {\n        var ret = [] // don't change original array\n          , l, i\n        for (i = 0, l = this.length; i < l; i++) ret[i] = cloneNode(opt_host || this, this[i])\n        return bonzo(ret)\n      }\n\n      // class management\n\n      /**\n       * @param {string} c\n       * @return {Bonzo}\n       */\n    , addClass: function (c) {\n        c = toString.call(c).split(whitespaceRegex)\n        return this.each(function (el) {\n          // we `each` here so you can do $el.addClass('foo bar')\n          each(c, function (c) {\n            if (c && !hasClass(el, setter(el, c)))\n              addClass(el, setter(el, c))\n          })\n        })\n      }\n\n\n      /**\n       * @param {string} c\n       * @return {Bonzo}\n       */\n    , removeClass: function (c) {\n        c = toString.call(c).split(whitespaceRegex)\n        return this.each(function (el) {\n          each(c, function (c) {\n            if (c && hasClass(el, setter(el, c)))\n              removeClass(el, setter(el, c))\n          })\n        })\n      }\n\n\n      /**\n       * @param {string} c\n       * @return {boolean}\n       */\n    , hasClass: function (c) {\n        c = toString.call(c).split(whitespaceRegex)\n        return some(this, function (el) {\n          return some(c, function (c) {\n            return c && hasClass(el, c)\n          })\n        })\n      }\n\n\n      /**\n       * @param {string} c classname to toggle\n       * @param {boolean=} opt_condition whether to add or remove the class straight away\n       * @return {Bonzo}\n       */\n    , toggleClass: function (c, opt_condition) {\n        c = toString.call(c).split(whitespaceRegex)\n        return this.each(function (el) {\n          each(c, function (c) {\n            if (c) {\n              typeof opt_condition !== 'undefined' ?\n                opt_condition ? !hasClass(el, c) && addClass(el, c) : removeClass(el, c) :\n                hasClass(el, c) ? removeClass(el, c) : addClass(el, c)\n            }\n          })\n        })\n      }\n\n      // display togglers\n\n      /**\n       * @param {string=} opt_type useful to set back to anything other than an empty string\n       * @return {Bonzo}\n       */\n    , show: function (opt_type) {\n        opt_type = typeof opt_type == 'string' ? opt_type : ''\n        return this.each(function (el) {\n          el.style.display = opt_type\n        })\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , hide: function () {\n        return this.each(function (el) {\n          el.style.display = 'none'\n        })\n      }\n\n\n      /**\n       * @param {Function=} opt_callback\n       * @param {string=} opt_type\n       * @return {Bonzo}\n       */\n    , toggle: function (opt_callback, opt_type) {\n        opt_type = typeof opt_type == 'string' ? opt_type : '';\n        typeof opt_callback != 'function' && (opt_callback = null)\n        return this.each(function (el) {\n          el.style.display = (el.offsetWidth || el.offsetHeight) ? 'none' : opt_type;\n          opt_callback && opt_callback.call(el)\n        })\n      }\n\n\n      // DOM Walkers & getters\n\n      /**\n       * @return {Element|Node}\n       */\n    , first: function () {\n        return bonzo(this.length ? this[0] : [])\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , last: function () {\n        return bonzo(this.length ? this[this.length - 1] : [])\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , next: function () {\n        return this.related('nextSibling')\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , previous: function () {\n        return this.related('previousSibling')\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , parent: function() {\n        return this.related(parentNode)\n      }\n\n\n      /**\n       * @private\n       * @param {string} method the directional DOM method\n       * @return {Element|Node}\n       */\n    , related: function (method) {\n        return bonzo(this.map(\n          function (el) {\n            el = el[method]\n            while (el && el.nodeType !== 1) {\n              el = el[method]\n            }\n            return el || 0\n          },\n          function (el) {\n            return el\n          }\n        ))\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , focus: function () {\n        this.length && this[0].focus()\n        return this\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , blur: function () {\n        this.length && this[0].blur()\n        return this\n      }\n\n      // style getter setter & related methods\n\n      /**\n       * @param {Object|string} o\n       * @param {string=} opt_v\n       * @return {Bonzo|string}\n       */\n    , css: function (o, opt_v) {\n        var p, iter = o\n        // is this a request for just getting a style?\n        if (opt_v === undefined && typeof o == 'string') {\n          // repurpose 'v'\n          opt_v = this[0]\n          if (!opt_v) return null\n          if (opt_v === doc || opt_v === win) {\n            p = (opt_v === doc) ? bonzo.doc() : bonzo.viewport()\n            return o == 'width' ? p.width : o == 'height' ? p.height : ''\n          }\n          return (o = styleProperty(o)) ? getStyle(opt_v, o) : null\n        }\n\n        if (typeof o == 'string') {\n          iter = {}\n          iter[o] = opt_v\n        }\n\n        function fn(el, p, v) {\n          for (var k in iter) {\n            if (iter.hasOwnProperty(k)) {\n              v = iter[k];\n              // change \"5\" to \"5px\" - unless you're line-height, which is allowed\n              (p = styleProperty(k)) && digit.test(v) && !(p in unitless) && (v += px)\n              try { el.style[p] = setter(el, v) } catch(e) {}\n            }\n          }\n        }\n        return this.each(fn)\n      }\n\n\n      /**\n       * @param {number=} opt_x\n       * @param {number=} opt_y\n       * @return {Bonzo|number}\n       */\n    , offset: function (opt_x, opt_y) {\n        if (opt_x && typeof opt_x == 'object' && (typeof opt_x.top == 'number' || typeof opt_x.left == 'number')) {\n          return this.each(function (el) {\n            xy(el, opt_x.left, opt_x.top)\n          })\n        } else if (typeof opt_x == 'number' || typeof opt_y == 'number') {\n          return this.each(function (el) {\n            xy(el, opt_x, opt_y)\n          })\n        }\n        if (!this[0]) return {\n            top: 0\n          , left: 0\n          , height: 0\n          , width: 0\n        }\n        var el = this[0]\n          , de = el.ownerDocument.documentElement\n          , bcr = el.getBoundingClientRect()\n          , scroll = getWindowScroll()\n          , width = el.offsetWidth\n          , height = el.offsetHeight\n          , top = bcr.top + scroll.y - Math.max(0, de && de.clientTop, doc.body.clientTop)\n          , left = bcr.left + scroll.x - Math.max(0, de && de.clientLeft, doc.body.clientLeft)\n\n        return {\n            top: top\n          , left: left\n          , height: height\n          , width: width\n        }\n      }\n\n\n      /**\n       * @return {number}\n       */\n    , dim: function () {\n        if (!this.length) return { height: 0, width: 0 }\n        var el = this[0]\n          , de = el.nodeType == 9 && el.documentElement // document\n          , orig = !de && !!el.style && !el.offsetWidth && !el.offsetHeight ?\n             // el isn't visible, can't be measured properly, so fix that\n             function (t) {\n               var s = {\n                   position: el.style.position || ''\n                 , visibility: el.style.visibility || ''\n                 , display: el.style.display || ''\n               }\n               t.first().css({\n                   position: 'absolute'\n                 , visibility: 'hidden'\n                 , display: 'block'\n               })\n               return s\n            }(this) : null\n          , width = de\n              ? Math.max(el.body.scrollWidth, el.body.offsetWidth, de.scrollWidth, de.offsetWidth, de.clientWidth)\n              : el.offsetWidth\n          , height = de\n              ? Math.max(el.body.scrollHeight, el.body.offsetHeight, de.scrollHeight, de.offsetHeight, de.clientHeight)\n              : el.offsetHeight\n\n        orig && this.first().css(orig)\n        return {\n            height: height\n          , width: width\n        }\n      }\n\n      // attributes are hard. go shopping\n\n      /**\n       * @param {string} k an attribute to get or set\n       * @param {string=} opt_v the value to set\n       * @return {Bonzo|string}\n       */\n    , attr: function (k, opt_v) {\n        var el = this[0]\n          , n\n\n        if (typeof k != 'string' && !(k instanceof String)) {\n          for (n in k) {\n            k.hasOwnProperty(n) && this.attr(n, k[n])\n          }\n          return this\n        }\n\n        return typeof opt_v == 'undefined' ?\n          !el ? null : specialAttributes.test(k) ?\n            stateAttributes.test(k) && typeof el[k] == 'string' ?\n              true : el[k] :  el[getAttribute](k) :\n          this.each(function (el) {\n            specialAttributes.test(k) ? (el[k] = setter(el, opt_v)) : el[setAttribute](k, setter(el, opt_v))\n          })\n      }\n\n\n      /**\n       * @param {string} k\n       * @return {Bonzo}\n       */\n    , removeAttr: function (k) {\n        return this.each(function (el) {\n          stateAttributes.test(k) ? (el[k] = false) : el.removeAttribute(k)\n        })\n      }\n\n\n      /**\n       * @param {string=} opt_s\n       * @return {Bonzo|string}\n       */\n    , val: function (s) {\n        return (typeof s == 'string' || typeof s == 'number') ?\n          this.attr('value', s) :\n          this.length ? this[0].value : null\n      }\n\n      // use with care and knowledge. this data() method uses data attributes on the DOM nodes\n      // to do this differently costs a lot more code. c'est la vie\n      /**\n       * @param {string|Object=} opt_k the key for which to get or set data\n       * @param {Object=} opt_v\n       * @return {Bonzo|Object}\n       */\n    , data: function (opt_k, opt_v) {\n        var el = this[0], o, m\n        if (typeof opt_v === 'undefined') {\n          if (!el) return null\n          o = data(el)\n          if (typeof opt_k === 'undefined') {\n            each(el.attributes, function (a) {\n              (m = ('' + a.name).match(dattr)) && (o[camelize(m[1])] = dataValue(a.value))\n            })\n            return o\n          } else {\n            if (typeof o[opt_k] === 'undefined')\n              o[opt_k] = dataValue(this.attr('data-' + decamelize(opt_k)))\n            return o[opt_k]\n          }\n        } else {\n          return this.each(function (el) { data(el)[opt_k] = opt_v })\n        }\n      }\n\n      // DOM detachment & related\n\n      /**\n       * @return {Bonzo}\n       */\n    , remove: function () {\n        this.deepEach(clearData)\n        return this.detach()\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , empty: function () {\n        return this.each(function (el) {\n          deepEach(el.childNodes, clearData)\n\n          while (el.firstChild) {\n            el.removeChild(el.firstChild)\n          }\n        })\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , detach: function () {\n        return this.each(function (el) {\n          el[parentNode] && el[parentNode].removeChild(el)\n        })\n      }\n\n      // who uses a mouse anyway? oh right.\n\n      /**\n       * @param {number} y\n       */\n    , scrollTop: function (y) {\n        return scroll.call(this, null, y, 'y')\n      }\n\n\n      /**\n       * @param {number} x\n       */\n    , scrollLeft: function (x) {\n        return scroll.call(this, x, null, 'x')\n      }\n\n  }\n\n\n  function cloneNode(host, el) {\n    var c = el.cloneNode(true)\n      , cloneElems\n      , elElems\n      , i\n\n    // check for existence of an event cloner\n    // preferably https://github.com/fat/bean\n    // otherwise Bonzo won't do this for you\n    if (host.$ && typeof host.cloneEvents == 'function') {\n      host.$(c).cloneEvents(el)\n\n      // clone events from every child node\n      cloneElems = host.$(c).find('*')\n      elElems = host.$(el).find('*')\n\n      for (i = 0; i < elElems.length; i++)\n        host.$(cloneElems[i]).cloneEvents(elElems[i])\n    }\n    return c\n  }\n\n  function isBody(element) {\n    return element === win || (/^(?:body|html)$/i).test(element.tagName)\n  }\n\n  function getWindowScroll() {\n    return { x: win.pageXOffset || html.scrollLeft, y: win.pageYOffset || html.scrollTop }\n  }\n\n  function createScriptFromHtml(html) {\n    var scriptEl = document.createElement('script')\n      , matches = html.match(simpleScriptTagRe)\n    scriptEl.src = matches[1]\n    return scriptEl\n  }\n\n  /**\n   * @param {Array.<Element>|Element|Node|string} els\n   * @return {Bonzo}\n   */\n  function bonzo(els) {\n    return new Bonzo(els)\n  }\n\n  bonzo.setQueryEngine = function (q) {\n    query = q;\n    delete bonzo.setQueryEngine\n  }\n\n  bonzo.aug = function (o, target) {\n    // for those standalone bonzo users. this love is for you.\n    for (var k in o) {\n      o.hasOwnProperty(k) && ((target || Bonzo.prototype)[k] = o[k])\n    }\n  }\n\n  bonzo.create = function (node) {\n    // hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n    return typeof node == 'string' && node !== '' ?\n      function () {\n        if (simpleScriptTagRe.test(node)) return [createScriptFromHtml(node)]\n        var tag = node.match(/^\\s*<([^\\s>]+)/)\n          , el = doc.createElement('div')\n          , els = []\n          , p = tag ? tagMap[tag[1].toLowerCase()] : null\n          , dep = p ? p[2] + 1 : 1\n          , ns = p && p[3]\n          , pn = parentNode\n\n        el.innerHTML = p ? (p[0] + node + p[1]) : node\n        while (dep--) el = el.firstChild\n        // for IE NoScope, we may insert cruft at the begining just to get it to work\n        if (ns && el && el.nodeType !== 1) el = el.nextSibling\n        do {\n          if (!tag || el.nodeType == 1) {\n            els.push(el)\n          }\n        } while (el = el.nextSibling)\n        // IE < 9 gives us a parentNode which messes up insert() check for cloning\n        // `dep` > 1 can also cause problems with the insert() check (must do this last)\n        each(els, function(el) { el[pn] && el[pn].removeChild(el) })\n        return els\n      }() : isNode(node) ? [node.cloneNode(true)] : []\n  }\n\n  bonzo.doc = function () {\n    var vp = bonzo.viewport()\n    return {\n        width: Math.max(doc.body.scrollWidth, html.scrollWidth, vp.width)\n      , height: Math.max(doc.body.scrollHeight, html.scrollHeight, vp.height)\n    }\n  }\n\n  bonzo.firstChild = function (el) {\n    for (var c = el.childNodes, i = 0, j = (c && c.length) || 0, e; i < j; i++) {\n      if (c[i].nodeType === 1) e = c[j = i]\n    }\n    return e\n  }\n\n  bonzo.viewport = function () {\n    return {\n        width: win.innerWidth\n      , height: win.innerHeight\n    }\n  }\n\n  bonzo.isAncestor = 'compareDocumentPosition' in html ?\n    function (container, element) {\n      return (container.compareDocumentPosition(element) & 16) == 16\n    } :\n    function (container, element) {\n      return container !== element && container.contains(element);\n    }\n\n  return bonzo\n}); // the only line we care about using a semi-colon. placed here for concatenation tools\n","/home/travis/build/npmtest/node-npmtest-bonzo/node_modules/bonzo/integration/ender.js":"/*!\n  * =============================================================\n  * Ender: open module JavaScript framework (https://ender.no.de)\n  * Build: ender build scriptjs bean domready qwery\n  * =============================================================\n  */\n\n/*!\n  * Ender-JS: open module JavaScript framework (client-lib)\n  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)\n  * https://ender.no.de\n  * License MIT\n  */\n!function (context) {\n\n  // a global object for node.js module compatiblity\n  // ============================================\n\n  context['global'] = context;\n\n  // Implements simple module system\n  // losely based on CommonJS Modules spec v1.1.1\n  // ============================================\n\n  var modules = {};\n\n  function require (identifier) {\n    var module = modules[identifier] || window[identifier];\n    if (!module) throw new Error(\"Requested module '\" + identifier + \"' has not been defined.\");\n    return module;\n  }\n\n  function provide (name, what) {\n    return modules[name] = what;\n  }\n\n  context['provide'] = provide;\n  context['require'] = require;\n\n  // Implements Ender's $ global access object\n  // =========================================\n\n  function aug(o, o2) {\n    for (var k in o2) {\n      k != 'noConflict' && k != '_VERSION' && (o[k] = o2[k]);\n    }\n    return o;\n  }\n\n  function boosh(s, r, els) {\n                          // string || node || nodelist || window\n    if (ender._select && (typeof s == 'string' || s.nodeName || s.length && 'item' in s || s == window)) {\n      els = ender._select(s, r);\n      els.selector = s;\n    } else {\n      els = isFinite(s.length) ? s : [s];\n    }\n    return aug(els, boosh);\n  }\n\n  function ender(s, r) {\n    return boosh(s, r);\n  }\n\n  aug(ender, {\n    _VERSION: '0.2.5',\n    ender: function (o, chain) {\n      aug(chain ? boosh : ender, o);\n    },\n    fn: context.$ && context.$.fn || {} // for easy compat to jQuery plugins\n  });\n\n  aug(boosh, {\n    forEach: function (fn, scope, i) {\n      // opt out of native forEach so we can intentionally call our own scope\n      // defaulting to the current item and be able to return self\n      for (i = 0, l = this.length; i < l; ++i) {\n        i in this && fn.call(scope || this[i], this[i], i, this);\n      }\n      // return self for chaining\n      return this;\n    },\n    $: ender // handy reference to self\n  });\n\n  var old = context.$;\n  ender.noConflict = function () {\n    context.$ = old;\n    return this;\n  };\n\n  (typeof module !== 'undefined') && module.exports && (module.exports = ender);\n  // use subscript notation as extern for Closure compilation\n  context['ender'] = context['$'] = context['ender'] || ender;\n\n}(this);\n\n!function () {\n\n  var module = { exports: {} }, exports = module.exports;\n\n  /*!\n    * $script.js v1.3\n    * https://github.com/ded/script.js\n    * Copyright: @ded & @fat - Dustin Diaz, Jacob Thornton 2011\n    * Follow our software http://twitter.com/dedfat\n    * License: MIT\n    */\n  !function(win, doc, timeout) {\n    var head = doc.getElementsByTagName('head')[0],\n        list = {}, ids = {}, delay = {},\n        scripts = {}, s = 'string', f = false,\n        push = 'push', domContentLoaded = 'DOMContentLoaded', readyState = 'readyState',\n        addEventListener = 'addEventListener', onreadystatechange = 'onreadystatechange',\n        every = function(ar, fn) {\n          for (var i = 0, j = ar.length; i < j; ++i) {\n            if (!fn(ar[i])) {\n              return f;\n            }\n          }\n          return 1;\n        };\n        function each(ar, fn) {\n          every(ar, function(el) {\n            return !fn(el);\n          });\n        }\n  \n    if (!doc[readyState] && doc[addEventListener]) {\n      doc[addEventListener](domContentLoaded, function fn() {\n        doc.removeEventListener(domContentLoaded, fn, f);\n        doc[readyState] = \"complete\";\n      }, f);\n      doc[readyState] = \"loading\";\n    }\n  \n    var $script = function(paths, idOrDone, optDone) {\n      paths = paths[push] ? paths : [paths];\n      var idOrDoneIsDone = idOrDone && idOrDone.call,\n          done = idOrDoneIsDone ? idOrDone : optDone,\n          id = idOrDoneIsDone ? paths.join('') : idOrDone,\n          queue = paths.length;\n      function loopFn(item) {\n        return item.call ? item() : list[item];\n      }\n      function callback() {\n        if (!--queue) {\n          list[id] = 1;\n          done && done();\n          for (var dset in delay) {\n            every(dset.split('|'), loopFn) && !each(delay[dset], loopFn) && (delay[dset] = []);\n          }\n        }\n      }\n      timeout(function() {\n        each(paths, function(path) {\n          if (scripts[path]) {\n            id && (ids[id] = 1);\n            scripts[path] == 2 && callback();\n            return;\n          }\n          scripts[path] = 1;\n          id && (ids[id] = 1);\n          create($script.path ?\n            $script.path + path + '.js' :\n            path, callback);\n        });\n      }, 0);\n      return $script;\n    };\n  \n    function create(path, fn) {\n      var el = doc.createElement(\"script\"),\n          loaded = f;\n      el.onload = el.onerror = el[onreadystatechange] = function () {\n        if ((el[readyState] && !(/^c|loade/.test(el[readyState]))) || loaded) {\n          return;\n        }\n        el.onload = el[onreadystatechange] = null;\n        loaded = 1;\n        scripts[path] = 2;\n        fn();\n      };\n      el.async = 1;\n      el.src = path;\n      head.insertBefore(el, head.firstChild);\n    }\n  \n    $script.get = create;\n  \n    $script.ready = function(deps, ready, req) {\n      deps = deps[push] ? deps : [deps];\n      var missing = [];\n      !each(deps, function(dep) {\n        list[dep] || missing[push](dep);\n      }) && every(deps, function(dep) {\n        return list[dep];\n      }) ? ready() : !function(key) {\n        delay[key] = delay[key] || [];\n        delay[key][push](ready);\n        req && req(missing);\n      }(deps.join('|'));\n      return $script;\n    };\n  \n    var old = win.$script;\n    $script.noConflict = function () {\n      win.$script = old;\n      return this;\n    };\n  \n    (typeof module !== 'undefined' && module.exports) ?\n      (module.exports = $script) :\n      (win['$script'] = $script);\n  \n  }(this, document, setTimeout);\n  \n\n  provide(\"scriptjs\", module.exports);\n\n  var $script = require('scriptjs');\n  ender.ender({\n    script: $script,\n    ready: $script.ready,\n    require: $script,\n    getScript: $script.get\n  });\n\n}();\n\n!function () {\n\n  var module = { exports: {} }, exports = module.exports;\n\n  /*!\n    * bean.js - copyright Jacob Thornton 2011\n    * https://github.com/fat/bean\n    * MIT License\n    * special thanks to:\n    * dean edwards: http://dean.edwards.name/\n    * dperini: https://github.com/dperini/nwevents\n    * the entire mootools team: github.com/mootools/mootools-core\n    */\n  !function (context) {\n    var __uid = 1,\n        registry = {},\n        collected = {},\n        overOut = /over|out/,\n        namespace = /[^\\.]*(?=\\..*)\\.|.*/,\n        stripName = /\\..*/,\n        addEvent = 'addEventListener',\n        attachEvent = 'attachEvent',\n        removeEvent = 'removeEventListener',\n        detachEvent = 'detachEvent',\n        doc = context.document || {},\n        root = doc.documentElement || {},\n        W3C_MODEL = root[addEvent],\n        eventSupport = W3C_MODEL ? addEvent : attachEvent,\n  \n    isDescendant = function (parent, child) {\n      var node = child.parentNode;\n      while (node !== null) {\n        if (node == parent) {\n          return true;\n        }\n        node = node.parentNode;\n      }\n    },\n  \n    retrieveUid = function (obj, uid) {\n      return (obj.__uid = uid && (uid + '::' + __uid++) || obj.__uid || __uid++);\n    },\n  \n    retrieveEvents = function (element) {\n      var uid = retrieveUid(element);\n      return (registry[uid] = registry[uid] || {});\n    },\n  \n    listener = W3C_MODEL ? function (element, type, fn, add) {\n      element[add ? addEvent : removeEvent](type, fn, false);\n    } : function (element, type, fn, add, custom) {\n      custom && add && (element['_on' + custom] = element['_on' + custom] || 0);\n      element[add ? attachEvent : detachEvent]('on' + type, fn);\n    },\n  \n    nativeHandler = function (element, fn, args) {\n      return function (event) {\n        event = fixEvent(event || ((this.ownerDocument || this.document || this).parentWindow || context).event);\n        return fn.apply(element, [event].concat(args));\n      };\n    },\n  \n    customHandler = function (element, fn, type, condition, args) {\n      return function (e) {\n        if (condition ? condition.apply(this, arguments) : W3C_MODEL ? true : e && e.propertyName == '_on' + type || !e) {\n          fn.apply(element, Array.prototype.slice.call(arguments, e ? 0 : 1).concat(args));\n        }\n      };\n    },\n  \n    addListener = function (element, orgType, fn, args) {\n      var type = orgType.replace(stripName, ''),\n          events = retrieveEvents(element),\n          handlers = events[type] || (events[type] = {}),\n          originalFn = fn,\n          uid = retrieveUid(fn, orgType.replace(namespace, ''));\n      if (handlers[uid]) {\n        return element;\n      }\n      var custom = customEvents[type];\n      if (custom) {\n        fn = custom.condition ? customHandler(element, fn, type, custom.condition) : fn;\n        type = custom.base || type;\n      }\n      var isNative = nativeEvents[type];\n      fn = isNative ? nativeHandler(element, fn, args) : customHandler(element, fn, type, false, args);\n      isNative = W3C_MODEL || isNative;\n      if (type == 'unload') {\n        var org = fn;\n        fn = function () {\n          removeListener(element, type, fn) && org();\n        };\n      }\n      element[eventSupport] && listener(element, isNative ? type : 'propertychange', fn, true, !isNative && type);\n      handlers[uid] = fn;\n      fn.__uid = uid;\n      fn.__originalFn = originalFn;\n      return type == 'unload' ? element : (collected[retrieveUid(element)] = element);\n    },\n  \n    removeListener = function (element, orgType, handler) {\n      var uid, names, uids, i, events = retrieveEvents(element), type = orgType.replace(stripName, '');\n      if (!events || !events[type]) {\n        return element;\n      }\n      names = orgType.replace(namespace, '');\n      uids = names ? names.split('.') : [handler.__uid];\n  \n      function destroyHandler(uid) {\n        handler = events[type][uid];\n        if (!handler) {\n          return;\n        }\n        delete events[type][uid];\n        if (element[eventSupport]) {\n          type = customEvents[type] ? customEvents[type].base : type;\n          var isNative = W3C_MODEL || nativeEvents[type];\n          listener(element, isNative ? type : 'propertychange', handler, false, !isNative && type);\n        }\n      }\n  \n      destroyHandler(names); //get combos\n      for (i = uids.length; i--; destroyHandler(uids[i])) {} //get singles\n  \n      return element;\n    },\n  \n    del = function (selector, fn, $) {\n      return function (e) {\n        var array = typeof selector == 'string' ? $(selector, this) : selector;\n        for (var target = e.target; target && target != this; target = target.parentNode) {\n          for (var i = array.length; i--;) {\n            if (array[i] == target) {\n              return fn.apply(target, arguments);\n            }\n          }\n        }\n      };\n    },\n  \n    add = function (element, events, fn, delfn, $) {\n      if (typeof events == 'object' && !fn) {\n        for (var type in events) {\n          events.hasOwnProperty(type) && add(element, type, events[type]);\n        }\n      } else {\n        var isDel = typeof fn == 'string', types = (isDel ? fn : events).split(' ');\n        fn = isDel ? del(events, delfn, $) : fn;\n        for (var i = types.length; i--;) {\n          addListener(element, types[i], fn, Array.prototype.slice.call(arguments, isDel ? 4 : 3));\n        }\n      }\n      return element;\n    },\n  \n    remove = function (element, orgEvents, fn) {\n      var k, m, type, events, i,\n          isString = typeof(orgEvents) == 'string',\n          names = isString && orgEvents.replace(namespace, ''),\n          names = names && names.split('.'),\n          rm = removeListener,\n          attached = retrieveEvents(element);\n      if (isString && /\\s/.test(orgEvents)) {\n        orgEvents = orgEvents.split(' ');\n        i = orgEvents.length - 1;\n        while (remove(element, orgEvents[i]) && i--) {}\n        return element;\n      }\n      events = isString ? orgEvents.replace(stripName, '') : orgEvents;\n      if (!attached || names || (isString && !attached[events])) {\n        for (k in attached) {\n          if (attached.hasOwnProperty(k)) {\n            for (i in attached[k]) {\n              for (m = names.length; m--;) {\n                attached[k].hasOwnProperty(i) && new RegExp('^' + names[m] + '::\\\\d*(\\\\..*)?$').test(i) && rm(element, [k, i].join('.'));\n              }\n            }\n          }\n        }\n        return element;\n      }\n      if (typeof fn == 'function') {\n        rm(element, events, fn);\n      } else if (names) {\n        rm(element, orgEvents);\n      } else {\n        rm = events ? rm : remove;\n        type = isString && events;\n        events = events ? (fn || attached[events] || events) : attached;\n        for (k in events) {\n          if (events.hasOwnProperty(k)) {\n            rm(element, type || k, events[k]);\n            delete events[k]; // remove unused leaf keys\n          }\n        }\n      }\n      return element;\n    },\n  \n    fire = function (element, type, args) {\n      var evt, k, i, m, types = type.split(' ');\n      for (i = types.length; i--;) {\n        type = types[i].replace(stripName, '');\n        var isNative = nativeEvents[type],\n            isNamespace = types[i].replace(namespace, ''),\n            handlers = retrieveEvents(element)[type];\n        if (isNamespace) {\n          isNamespace = isNamespace.split('.');\n          for (k = isNamespace.length; k--;) {\n            for (m in handlers) {\n              handlers.hasOwnProperty(m) && new RegExp('^' + isNamespace[k] + '::\\\\d*(\\\\..*)?$').test(m) && handlers[m].apply(element, [false].concat(args));\n            }\n          }\n        } else if (!args && element[eventSupport]) {\n          fireListener(isNative, type, element);\n        } else {\n          for (k in handlers) {\n            handlers.hasOwnProperty(k) && handlers[k].apply(element, [false].concat(args));\n          }\n        }\n      }\n      return element;\n    },\n  \n    fireListener = W3C_MODEL ? function (isNative, type, element) {\n      evt = document.createEvent(isNative ? \"HTMLEvents\" : \"UIEvents\");\n      evt[isNative ? 'initEvent' : 'initUIEvent'](type, true, true, context, 1);\n      element.dispatchEvent(evt);\n    } : function (isNative, type, element) {\n      isNative ? element.fireEvent('on' + type, document.createEventObject()) : element['_on' + type]++;\n    },\n  \n    clone = function (element, from, type) {\n      var events = retrieveEvents(from), obj, k;\n      var uid = retrieveUid(element);\n      obj = type ? events[type] : events;\n      for (k in obj) {\n        obj.hasOwnProperty(k) && (type ? add : clone)(element, type || from, type ? obj[k].__originalFn : k);\n      }\n      return element;\n    },\n  \n    fixEvent = function (e) {\n      var result = {};\n      if (!e) {\n        return result;\n      }\n      var type = e.type, target = e.target || e.srcElement;\n      result.preventDefault = fixEvent.preventDefault(e);\n      result.stopPropagation = fixEvent.stopPropagation(e);\n      result.target = target && target.nodeType == 3 ? target.parentNode : target;\n      if (~type.indexOf('key')) {\n        result.keyCode = e.which || e.keyCode;\n      } else if ((/click|mouse|menu/i).test(type)) {\n        result.rightClick = e.which == 3 || e.button == 2;\n        result.pos = { x: 0, y: 0 };\n        if (e.pageX || e.pageY) {\n          result.clientX = e.pageX;\n          result.clientY = e.pageY;\n        } else if (e.clientX || e.clientY) {\n          result.clientX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n          result.clientY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n        overOut.test(type) && (result.relatedTarget = e.relatedTarget || e[(type == 'mouseover' ? 'from' : 'to') + 'Element']);\n      }\n      for (var k in e) {\n        if (!(k in result)) {\n          result[k] = e[k];\n        }\n      }\n      return result;\n    };\n  \n    fixEvent.preventDefault = function (e) {\n      return function () {\n        if (e.preventDefault) {\n          e.preventDefault();\n        }\n        else {\n          e.returnValue = false;\n        }\n      };\n    };\n  \n    fixEvent.stopPropagation = function (e) {\n      return function () {\n        if (e.stopPropagation) {\n          e.stopPropagation();\n        } else {\n          e.cancelBubble = true;\n        }\n      };\n    };\n  \n    var nativeEvents = { click: 1, dblclick: 1, mouseup: 1, mousedown: 1, contextmenu: 1, //mouse buttons\n      mousewheel: 1, DOMMouseScroll: 1, //mouse wheel\n      mouseover: 1, mouseout: 1, mousemove: 1, selectstart: 1, selectend: 1, //mouse movement\n      keydown: 1, keypress: 1, keyup: 1, //keyboard\n      orientationchange: 1, // mobile\n      touchstart: 1, touchmove: 1, touchend: 1, touchcancel: 1, // touch\n      gesturestart: 1, gesturechange: 1, gestureend: 1, // gesture\n      focus: 1, blur: 1, change: 1, reset: 1, select: 1, submit: 1, //form elements\n      load: 1, unload: 1, beforeunload: 1, resize: 1, move: 1, DOMContentLoaded: 1, readystatechange: 1, //window\n      error: 1, abort: 1, scroll: 1 }; //misc\n  \n    function check(event) {\n      var related = event.relatedTarget;\n      if (!related) {\n        return related === null;\n      }\n      return (related != this && related.prefix != 'xul' && !/document/.test(this.toString()) && !isDescendant(this, related));\n    }\n  \n    var customEvents = {\n      mouseenter: { base: 'mouseover', condition: check },\n      mouseleave: { base: 'mouseout', condition: check },\n      mousewheel: { base: /Firefox/.test(navigator.userAgent) ? 'DOMMouseScroll' : 'mousewheel' }\n    };\n  \n    var bean = { add: add, remove: remove, clone: clone, fire: fire };\n  \n    var clean = function (el) {\n      var uid = remove(el).__uid;\n      if (uid) {\n        delete collected[uid];\n        delete registry[uid];\n      }\n    };\n  \n    if (context[attachEvent]) {\n      add(context, 'unload', function () {\n        for (var k in collected) {\n          collected.hasOwnProperty(k) && clean(collected[k]);\n        }\n        context.CollectGarbage && CollectGarbage();\n      });\n    }\n  \n    var oldBean = context.bean;\n    bean.noConflict = function () {\n      context.bean = oldBean;\n      return this;\n    };\n  \n    (typeof module !== 'undefined' && module.exports) ?\n      (module.exports = bean) :\n      (context['bean'] = bean);\n  \n  }(this);\n\n  provide(\"bean\", module.exports);\n\n  !function ($) {\n    var b = require('bean'),\n        integrate = function (method, type, method2) {\n          var _args = type ? [type] : [];\n          return function () {\n            for (var args, i = 0, l = this.length; i < l; i++) {\n              args = [this[i]].concat(_args, Array.prototype.slice.call(arguments, 0));\n              args.length == 4 && args.push($);\n              !arguments.length && method == 'add' && type && (method = 'fire');\n              b[method].apply(this, args);\n            }\n            return this;\n          };\n        };\n  \n    var add = integrate('add'),\n        remove = integrate('remove'),\n        fire = integrate('fire');\n  \n    var methods = {\n  \n      on: add,\n      addListener: add,\n      bind: add,\n      listen: add,\n      delegate: add,\n  \n      unbind: remove,\n      unlisten: remove,\n      removeListener: remove,\n      undelegate: remove,\n  \n      emit: fire,\n      trigger: fire,\n  \n      cloneEvents: integrate('clone'),\n  \n      hover: function (enter, leave, i) { // i for internal\n        for (i = this.length; i--;) {\n          b.add.call(this, this[i], 'mouseenter', enter);\n          b.add.call(this, this[i], 'mouseleave', leave);\n        }\n        return this;\n      }\n    };\n  \n    var i, shortcuts = [\n      'blur', 'change', 'click', 'dblclick', 'error', 'focus', 'focusin',\n      'focusout', 'keydown', 'keypress', 'keyup', 'load', 'mousedown',\n      'mouseenter', 'mouseleave', 'mouseout', 'mouseover', 'mouseup', 'mousemove',\n      'resize', 'scroll', 'select', 'submit', 'unload'\n    ];\n  \n    for (i = shortcuts.length; i--;) {\n      methods[shortcuts[i]] = integrate('add', shortcuts[i]);\n    }\n  \n    $.ender(methods, true);\n  }(ender);\n\n}();\n\n!function () {\n\n  var module = { exports: {} }, exports = module.exports;\n\n  !function (context, doc) {\n    var fns = [], ol, fn, f = false,\n        testEl = doc.documentElement,\n        hack = testEl.doScroll,\n        domContentLoaded = 'DOMContentLoaded',\n        addEventListener = 'addEventListener',\n        onreadystatechange = 'onreadystatechange',\n        loaded = /^loade|c/.test(doc.readyState);\n  \n    function flush(i) {\n      loaded = 1;\n      while (i = fns.shift()) { i() }\n    }\n    doc[addEventListener] && doc[addEventListener](domContentLoaded, fn = function () {\n      doc.removeEventListener(domContentLoaded, fn, f);\n      flush();\n    }, f);\n  \n  \n    hack && doc.attachEvent(onreadystatechange, (ol = function () {\n      if (/^c/.test(doc.readyState)) {\n        doc.detachEvent(onreadystatechange, ol);\n        flush();\n      }\n    }));\n  \n    context['domReady'] = hack ?\n      function (fn) {\n        self != top ?\n          loaded ? fn() : fns.push(fn) :\n          function () {\n            try {\n              testEl.doScroll('left');\n            } catch (e) {\n              return setTimeout(function() { context['domReady'](fn) }, 50);\n            }\n            fn();\n          }()\n      } :\n      function (fn) {\n        loaded ? fn() : fns.push(fn);\n      };\n  \n  }(this, document);\n  \n\n  provide(\"domready\", module.exports);\n\n  !function ($) {\n    $.ender({domReady: domReady});\n    $.ender({\n      ready: function (f) {\n        domReady(f);\n        return this;\n      }\n    }, true);\n  }(ender);\n\n}();\n\n!function () {\n\n  var module = { exports: {} }, exports = module.exports;\n\n  /*!\n    * Qwery - A Blazing Fast query selector engine\n    * https://github.com/ded/qwery\n    * copyright Dustin Diaz & Jacob Thornton 2011\n    * MIT License\n    */\n  \n  !function (context, doc) {\n  \n    var c, i, j, k, l, m, o, p, r, v,\n        el, node, len, found, classes, item, items, token,\n        html = doc.documentElement,\n        id = /#([\\w\\-]+)/,\n        clas = /\\.[\\w\\-]+/g,\n        idOnly = /^#([\\w\\-]+$)/,\n        classOnly = /^\\.([\\w\\-]+)$/,\n        tagOnly = /^([\\w\\-]+)$/,\n        tagAndOrClass = /^([\\w]+)?\\.([\\w\\-]+)$/,\n        normalizr = /\\s*([\\s\\+\\~>])\\s*/g,\n        splitters = /[\\s\\>\\+\\~]/,\n        splittersMore = /(?![\\s\\w\\-\\/\\?\\&\\=\\:\\.\\(\\)\\!,@#%<>\\{\\}\\$\\*\\^'\"]*\\])/,\n        dividers = new RegExp('(' + splitters.source + ')' + splittersMore.source, 'g'),\n        tokenizr = new RegExp(splitters.source + splittersMore.source),\n        specialChars = /([.*+?\\^=!:${}()|\\[\\]\\/\\\\])/g,\n        simple = /^([a-z0-9]+)?(?:([\\.\\#]+[\\w\\-\\.#]+)?)/,\n        attr = /\\[([\\w\\-]+)(?:([\\|\\^\\$\\*\\~]?\\=)['\"]?([ \\w\\-\\/\\?\\&\\=\\:\\.\\(\\)\\!,@#%<>\\{\\}\\$\\*\\^]+)[\"']?)?\\]/,\n        pseudo = /:([\\w\\-]+)(\\(['\"]?(\\w+)['\"]?\\))?/,\n        chunker = new RegExp(simple.source + '(' + attr.source + ')?' + '(' + pseudo.source + ')?'),\n        walker = {\n      ' ': function (node) {\n        return node && node !== html && node.parentNode\n      },\n      '>': function (node, contestant) {\n        return node && node.parentNode == contestant.parentNode && node.parentNode;\n      },\n      '~': function (node) {\n        return node && node.previousSibling;\n      },\n      '+': function (node, contestant, p1, p2) {\n        if (!node) {\n          return false;\n        }\n        p1 = previous(node);\n        p2 = previous(contestant);\n        return p1 && p2 && p1 == p2 && p1;\n      }\n    };\n    function cache() {\n      this.c = {};\n    }\n    cache.prototype = {\n      g: function (k) {\n        return this.c[k] || undefined;\n      },\n      s: function (k, v) {\n        this.c[k] = v;\n        return v;\n      }\n    };\n  \n    var classCache = new cache(),\n        cleanCache = new cache(),\n        attrCache = new cache(),\n        tokenCache = new cache();\n  \n    function array(ar) {\n      r = [];\n      for (i = 0, len = ar.length; i < len; i++) {\n        r[i] = ar[i];\n      }\n      return r;\n    }\n  \n    function previous(n) {\n      while (n = n.previousSibling) {\n        if (n.nodeType == 1) {\n          break;\n        }\n      }\n      return n\n    }\n  \n    function q(query) {\n      return query.match(chunker);\n    }\n  \n    // this next method expect at most these args\n    // given => div.hello[title=\"world\"]:foo('bar')\n  \n    // div.hello[title=\"world\"]:foo('bar'), div, .hello, [title=\"world\"], title, =, world, :foo('bar'), foo, ('bar'), bar]\n  \n    function interpret(whole, tag, idsAndClasses, wholeAttribute, attribute, qualifier, value, wholePseudo, pseudo, wholePseudoVal, pseudoVal) {\n      var m, c, k;\n      if (tag && this.tagName.toLowerCase() !== tag) {\n        return false;\n      }\n      if (idsAndClasses && (m = idsAndClasses.match(id)) && m[1] !== this.id) {\n        return false;\n      }\n      if (idsAndClasses && (classes = idsAndClasses.match(clas))) {\n        for (i = classes.length; i--;) {\n          c = classes[i].slice(1);\n          if (!(classCache.g(c) || classCache.s(c, new RegExp('(^|\\\\s+)' + c + '(\\\\s+|$)'))).test(this.className)) {\n            return false;\n          }\n        }\n      }\n      if (pseudo && qwery.pseudos[pseudo] && !qwery.pseudos[pseudo](this, pseudoVal)) {\n        return false;\n      }\n      if (wholeAttribute && !value) {\n        o = this.attributes;\n        for (k in o) {\n          if (Object.prototype.hasOwnProperty.call(o, k) && (o[k].name || k) == attribute) {\n            return this;\n          }\n        }\n      }\n      if (wholeAttribute && !checkAttr(qualifier, this.getAttribute(attribute) || '', value)) {\n        return false;\n      }\n      return this;\n    }\n  \n    function clean(s) {\n      return cleanCache.g(s) || cleanCache.s(s, s.replace(specialChars, '\\\\$1'));\n    }\n  \n    function checkAttr(qualify, actual, val) {\n      switch (qualify) {\n      case '=':\n        return actual == val;\n      case '^=':\n        return actual.match(attrCache.g('^=' + val) || attrCache.s('^=' + val, new RegExp('^' + clean(val))));\n      case '$=':\n        return actual.match(attrCache.g('$=' + val) || attrCache.s('$=' + val, new RegExp(clean(val) + '$')));\n      case '*=':\n        return actual.match(attrCache.g(val) || attrCache.s(val, new RegExp(clean(val))));\n      case '~=':\n        return actual.match(attrCache.g('~=' + val) || attrCache.s('~=' + val, new RegExp('(?:^|\\\\s+)' + clean(val) + '(?:\\\\s+|$)')));\n      case '|=':\n        return actual.match(attrCache.g('|=' + val) || attrCache.s('|=' + val, new RegExp('^' + clean(val) + '(-|$)')));\n      }\n      return 0;\n    }\n  \n    function _qwery(selector) {\n      var r = [], ret = [], i, j = 0, k, l, m, p, token, tag, els, root, intr, item, children,\n          tokens = tokenCache.g(selector) || tokenCache.s(selector, selector.split(tokenizr)),\n          dividedTokens = selector.match(dividers), dividedToken;\n      tokens = tokens.slice(0); // this makes a copy of the array so the cached original is not effected\n      if (!tokens.length) {\n        return r;\n      }\n  \n      token = tokens.pop();\n      root = tokens.length && (m = tokens[tokens.length - 1].match(idOnly)) ? doc.getElementById(m[1]) : doc;\n      if (!root) {\n        return r;\n      }\n      intr = q(token);\n      els = dividedTokens && /^[+~]$/.test(dividedTokens[dividedTokens.length - 1]) ? function (r) {\n          while (root = root.nextSibling) {\n            root.nodeType == 1 && (intr[1] ? intr[1] == root.tagName.toLowerCase() : 1) && r.push(root)\n          }\n          return r\n        }([]) :\n        root.getElementsByTagName(intr[1] || '*');\n      for (i = 0, l = els.length; i < l; i++) {\n        if (item = interpret.apply(els[i], intr)) {\n          r[j++] = item;\n        }\n      }\n      if (!tokens.length) {\n        return r;\n      }\n  \n      // loop through all descendent tokens\n      for (j = 0, l = r.length, k = 0; j < l; j++) {\n        p = r[j];\n        // loop through each token backwards crawling up tree\n        for (i = tokens.length; i--;) {\n          // loop through parent nodes\n          while (p = walker[dividedTokens[i]](p, r[j])) {\n            if (found = interpret.apply(p, q(tokens[i]))) {\n              break;\n            }\n          }\n        }\n        found && (ret[k++] = r[j]);\n      }\n      return ret;\n    }\n  \n    function boilerPlate(selector, _root, fn) {\n      var root = (typeof _root == 'string') ? fn(_root)[0] : (_root || doc);\n      if (selector === window || isNode(selector)) {\n        return !_root || (selector !== window && isNode(root) && isAncestor(selector, root)) ? [selector] : [];\n      }\n      if (selector && typeof selector === 'object' && isFinite(selector.length)) {\n        return array(selector);\n      }\n      if (m = selector.match(idOnly)) {\n        return (el = doc.getElementById(m[1])) ? [el] : [];\n      }\n      if (m = selector.match(tagOnly)) {\n        return array(root.getElementsByTagName(m[1]));\n      }\n      return false;\n    }\n  \n    function isNode(el) {\n      return (el && el.nodeType && (el.nodeType == 1 || el.nodeType == 9));\n    }\n  \n    function uniq(ar) {\n      var a = [], i, j;\n      label:\n      for (i = 0; i < ar.length; i++) {\n        for (j = 0; j < a.length; j++) {\n          if (a[j] == ar[i]) {\n            continue label;\n          }\n        }\n        a[a.length] = ar[i];\n      }\n      return a;\n    }\n  \n    function qwery(selector, _root) {\n      var root = (typeof _root == 'string') ? qwery(_root)[0] : (_root || doc);\n      if (!root || !selector) {\n        return [];\n      }\n      if (m = boilerPlate(selector, _root, qwery)) {\n        return m;\n      }\n      return select(selector, root);\n    }\n  \n    var isAncestor = 'compareDocumentPosition' in html ?\n      function (element, container) {\n        return (container.compareDocumentPosition(element) & 16) == 16;\n      } : 'contains' in html ?\n      function (element, container) {\n        container = container == doc || container == window ? html : container;\n        return container !== element && container.contains(element);\n      } :\n      function (element, container) {\n        while (element = element.parentNode) {\n          if (element === container) {\n            return 1;\n          }\n        }\n        return 0;\n      },\n  \n    select = (doc.querySelector && doc.querySelectorAll) ?\n      function (selector, root) {\n        if (doc.getElementsByClassName && (m = selector.match(classOnly))) {\n          return array((root).getElementsByClassName(m[1]));\n        }\n        return array((root).querySelectorAll(selector));\n      } :\n      function (selector, root) {\n        selector = selector.replace(normalizr, '$1');\n        var result = [], collection, collections = [], i;\n        if (m = selector.match(tagAndOrClass)) {\n          items = root.getElementsByTagName(m[1] || '*');\n          r = classCache.g(m[2]) || classCache.s(m[2], new RegExp('(^|\\\\s+)' + m[2] + '(\\\\s+|$)'));\n          for (i = 0, l = items.length, j = 0; i < l; i++) {\n            r.test(items[i].className) && (result[j++] = items[i]);\n          }\n          return result;\n        }\n        for (i = 0, items = selector.split(','), l = items.length; i < l; i++) {\n          collections[i] = _qwery(items[i]);\n        }\n        for (i = 0, l = collections.length; i < l && (collection = collections[i]); i++) {\n          var ret = collection;\n          if (root !== doc) {\n            ret = [];\n            for (j = 0, m = collection.length; j < m && (element = collection[j]); j++) {\n              // make sure element is a descendent of root\n              isAncestor(element, root) && ret.push(element);\n            }\n          }\n          result = result.concat(ret);\n        }\n        return uniq(result);\n      };\n  \n    qwery.uniq = uniq;\n    qwery.pseudos = {};\n  \n    var oldQwery = context.qwery;\n    qwery.noConflict = function () {\n      context.qwery = oldQwery;\n      return this;\n    };\n    context['qwery'] = qwery;\n  \n  }(this, document);\n\n  provide(\"qwery\", module.exports);\n\n  !function (doc) {\n    var q = qwery.noConflict();\n    var table = 'table',\n        nodeMap = {\n          thead: table,\n          tbody: table,\n          tfoot: table,\n          tr: 'tbody',\n          th: 'tr',\n          td: 'tr',\n          fieldset: 'form',\n          option: 'select'\n        }\n    function create(node, root) {\n      var tag = /^<([^\\s>]+)/.exec(node)[1]\n      var el = (root || doc).createElement(nodeMap[tag] || 'div'), els = [];\n      el.innerHTML = node;\n      var nodes = el.childNodes;\n      el = el.firstChild;\n      els.push(el);\n      while (el = el.nextSibling) {\n        (el.nodeType == 1) && els.push(el);\n      }\n      return els;\n    }\n    $._select = function (s, r) {\n      return /^\\s*</.test(s) ? create(s, r) : q(s, r);\n    };\n    $.pseudos = q.pseudos;\n    $.ender({\n      find: function (s) {\n        var r = [], i, l, j, k, els;\n        for (i = 0, l = this.length; i < l; i++) {\n          els = q(s, this[i]);\n          for (j = 0, k = els.length; j < k; j++) {\n            r.push(els[j]);\n          }\n        }\n        return $(q.uniq(r));\n      }\n      , and: function (s) {\n        var plus = $(s);\n        for (var i = this.length, j = 0, l = this.length + plus.length; i < l; i++, j++) {\n          this[i] = plus[j];\n        }\n        return this;\n      }\n    }, true);\n  }(document);\n\n}();","/home/travis/build/npmtest/node-npmtest-bonzo/node_modules/bonzo/integration/integration.js":"sink('Ender', function(test, ok, before, after) {\n  function byid(id) { return document.getElementById(id); }\n\n  test('classes', 2, function() {\n    var parents = $('#get-me').parents('div.robustr').addClass('aloha');\n    parents.each(function (el, i) {\n      $(el).addClass(i + '');\n    });\n    $('#get-me').closest('.robustr').addClass('closest robusto');\n\n    var getme = byid('get-me');\n    ok(getme.parentNode.className === 'robustr aloha 0 closest robusto', 'first parent has correct ');\n    ok(getme.parentNode.parentNode.className === 'robustr aloha 1', 'second parent has correct class');\n  });\n\n  test('val', 1, function() {\n    $('#input-test input[type=text]').val('hello');\n    var input = document.getElementById('input-fixture');\n    ok(input.value == 'hello', 'input value set');\n  });\n\n  test('css', 6, function() {\n    var li = $('#color-test li');\n    li.first().css('color', 'red').next().css('color', 'blue');\n    li.last().css('color', 'green');\n    ok(byid('first').style.color == 'red', 'first elem has color red');\n    ok(byid('second').style.color == 'blue', 'second elem has color blue');\n    ok(byid('last').style.color == 'green', 'third elem has color green');\n\n    $('body').css({\n      width: 500,\n      margin: '0 auto',\n      font: '300 14px/1.5 helvetica neue'\n    });\n\n    var style = document.body.style;\n    ok(style.width == '500px', 'has width 500 px');\n\n    // Style attribute output changes depending on browser. These only work\n    // in Chrome. How best to test consistently?\n    ok(style.margin == '0px auto', 'has margin 0 auto');\n    ok(style.font.replace(/'/g, '') == \"300 14px/1.5 helvetica neue\", 'has correct font' + style.font);\n  });\n\n  test('creation', 3, function() {\n    // append <em style=\"color:purple\"> asdf </em>\n    $('<em/>').css('color', 'purple').prependTo('#append-test-1 li').html(' asdf ');\n\n    // append <b style=\"color:orange\"> asdf </b>\n    $('<b/>').appendTo('#append-test-1 li').css('color', 'orange').html(' asdf ');\n\n    // append <li style=\"background:lightpink\">extre<li>\n    $('<li>extre</li>').insertAfter('#append-test-1 li').css('background', 'lightpink');\n    \n    var li = $('#append-test-1').children();\n    ok(li.length === 4, 'has 4 children');\n    ok(li[0].innerHTML = '<em style=\"color: purple; \"> asdf </em><b style=\"color: orange; \"> asdf </b>', 'first li has correct elems');\n    ok(li[2].innerHTML = '<em style=\"color: purple; \"> asdf </em><b style=\"color: orange; \"> asdf </b>', 'third li has correct elems');\n  });\n\n  test('cloning', 2, function() {\n    var outer = $('<div>i have a click handler<div>i have focus handler</div></div>')\n      .css('cursor', 'pointer')\n      .bind('click', function() {\n        ok(true, 'click handler fired');\n      });\n\n    var inner = outer.find('div').bind('focus', function() {\n        ok(true, 'focus handler fired');\n      });\n\n    // Using 'after' because it clones\n    $('#fixtures').children().last().after(outer);\n\n    outer.trigger('click');\n    inner.trigger('focus');\n  });\n\n  test('transfer', 3, function() {\n    $('.hello').appendTo('#hello-world');\n    var hw = byid('hello-world');\n    var hello = document.getElementsByClassName('hello');\n    ok(hello.length === 2, \"didn't create new elements\");\n    ok(hello[0].parentNode == hw, 'moved first elem');\n    ok(hello[1].parentNode == hw, 'moved second elem');\n  });\n\n});\n\nstart();\n","/home/travis/build/npmtest/node-npmtest-bonzo/node_modules/bonzo/make/release.js":"var fs = require('fs')\n\nfs.readFile('package.json', 'utf8', function (err, data) {\n  var re = /\\\"version\\\": \\\"(\\d+)\\.(\\d+)\\.(\\d+)\\\"/\n  var m = data.match(re)\n  var currentPatchVersion = parseInt(m[3], 10)\n  var newFileData = data.replace(re, '\"version\": \"$1.$2.' + (++currentPatchVersion) + '\"');\n\n  ['package.json', 'component.json'].forEach(function (file) {\n    fs.writeFile(file, newFileData, 'utf8', function (err) {\n      if (!err) console.log(file, 'saved successfully')\n    })\n  })\n})\n","/home/travis/build/npmtest/node-npmtest-bonzo/node_modules/bonzo/src/bonzo.js":"(function (name, context, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (typeof define == 'function' && define.amd) define(definition)\n  else context[name] = definition()\n})('bonzo', this, function() {\n  var win = window\n    , doc = win.document\n    , html = doc.documentElement\n    , parentNode = 'parentNode'\n    , specialAttributes = /^(checked|value|selected|disabled)$/i\n      // tags that we have trouble inserting *into*\n    , specialTags = /^(select|fieldset|table|tbody|tfoot|td|tr|colgroup)$/i\n    , simpleScriptTagRe = /\\s*<script +src=['\"]([^'\"]+)['\"]>/\n    , table = ['<table>', '</table>', 1]\n    , td = ['<table><tbody><tr>', '</tr></tbody></table>', 3]\n    , option = ['<select>', '</select>', 1]\n    , noscope = ['_', '', 0, 1]\n    , tagMap = { // tags that we have trouble *inserting*\n          thead: table, tbody: table, tfoot: table, colgroup: table, caption: table\n        , tr: ['<table><tbody>', '</tbody></table>', 2]\n        , th: td , td: td\n        , col: ['<table><colgroup>', '</colgroup></table>', 2]\n        , fieldset: ['<form>', '</form>', 1]\n        , legend: ['<form><fieldset>', '</fieldset></form>', 2]\n        , option: option, optgroup: option\n        , script: noscope, style: noscope, link: noscope, param: noscope, base: noscope\n      }\n    , stateAttributes = /^(checked|selected|disabled)$/\n    , hasClass, addClass, removeClass\n    , uidMap = {}\n    , uuids = 0\n    , digit = /^-?[\\d\\.]+$/\n    , dattr = /^data-(.+)$/\n    , px = 'px'\n    , setAttribute = 'setAttribute'\n    , getAttribute = 'getAttribute'\n    , features = function() {\n        var e = doc.createElement('p')\n        return {\n          transform: function () {\n            var props = ['transform', 'webkitTransform', 'MozTransform', 'OTransform', 'msTransform'], i\n            for (i = 0; i < props.length; i++) {\n              if (props[i] in e.style) return props[i]\n            }\n          }()\n        , classList: 'classList' in e\n        }\n      }()\n    , whitespaceRegex = /\\s+/\n    , toString = String.prototype.toString\n    , unitless = { lineHeight: 1, zoom: 1, zIndex: 1, opacity: 1, boxFlex: 1, WebkitBoxFlex: 1, MozBoxFlex: 1 }\n    , query = doc.querySelectorAll && function (selector) { return doc.querySelectorAll(selector) }\n\n\n  function getStyle(el, property) {\n    var value = null\n      , computed = doc.defaultView.getComputedStyle(el, '')\n    computed && (value = computed[property])\n    return el.style[property] || value\n  }\n\n\n  function isNode(node) {\n    return node && node.nodeName && (node.nodeType == 1 || node.nodeType == 11)\n  }\n\n\n  function normalize(node, host, clone) {\n    var i, l, ret\n    if (typeof node == 'string') return bonzo.create(node)\n    if (isNode(node)) node = [ node ]\n    if (clone) {\n      ret = [] // don't change original array\n      for (i = 0, l = node.length; i < l; i++) ret[i] = cloneNode(host, node[i])\n      return ret\n    }\n    return node\n  }\n\n  /**\n   * @param {string} c a class name to test\n   * @return {boolean}\n   */\n  function classReg(c) {\n    return new RegExp('(^|\\\\s+)' + c + '(\\\\s+|$)')\n  }\n\n\n  /**\n   * @param {Bonzo|Array} ar\n   * @param {function(Object, number, (Bonzo|Array))} fn\n   * @param {Object=} opt_scope\n   * @param {boolean=} opt_rev\n   * @return {Bonzo|Array}\n   */\n  function each(ar, fn, opt_scope, opt_rev) {\n    var ind, i = 0, l = ar.length\n    for (; i < l; i++) {\n      ind = opt_rev ? ar.length - i - 1 : i\n      fn.call(opt_scope || ar[ind], ar[ind], ind, ar)\n    }\n    return ar\n  }\n\n\n  /**\n   * @param {Bonzo|Array} ar\n   * @param {function(Object, number, (Bonzo|Array))} fn\n   * @param {Object=} opt_scope\n   * @return {Bonzo|Array}\n   */\n  function deepEach(ar, fn, opt_scope) {\n    for (var i = 0, l = ar.length; i < l; i++) {\n      if (isNode(ar[i])) {\n        deepEach(ar[i].childNodes, fn, opt_scope)\n        fn.call(opt_scope || ar[i], ar[i], i, ar)\n      }\n    }\n    return ar\n  }\n\n\n  /**\n   * @param {string} s\n   * @return {string}\n   */\n  function camelize(s) {\n    return s.replace(/-(.)/g, function (m, m1) {\n      return m1.toUpperCase()\n    })\n  }\n\n\n  /**\n   * @param {string} s\n   * @return {string}\n   */\n  function decamelize(s) {\n    return s ? s.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() : s\n  }\n\n\n  /**\n   * @param {Element} el\n   * @return {*}\n   */\n  function data(el) {\n    el[getAttribute]('data-node-uid') || el[setAttribute]('data-node-uid', ++uuids)\n    var uid = el[getAttribute]('data-node-uid')\n    return uidMap[uid] || (uidMap[uid] = {})\n  }\n\n\n  /**\n   * removes the data associated with an element\n   * @param {Element} el\n   */\n  function clearData(el) {\n    var uid = el[getAttribute]('data-node-uid')\n    if (uid) delete uidMap[uid]\n  }\n\n\n  function dataValue(d) {\n    var f\n    try {\n      return (d === null || d === undefined) ? undefined :\n        d === 'true' ? true :\n          d === 'false' ? false :\n            d === 'null' ? null :\n              (f = parseFloat(d)) == d ? f : d;\n    } catch(e) {}\n    return undefined\n  }\n\n\n  /**\n   * @param {Bonzo|Array} ar\n   * @param {function(Object, number, (Bonzo|Array))} fn\n   * @param {Object=} opt_scope\n   * @return {boolean} whether `some`thing was found\n   */\n  function some(ar, fn, opt_scope) {\n    for (var i = 0, j = ar.length; i < j; ++i) if (fn.call(opt_scope || null, ar[i], i, ar)) return true\n    return false\n  }\n\n\n  /**\n   * this could be a giant enum of CSS properties\n   * but in favor of file size sans-closure deadcode optimizations\n   * we're just asking for any ol string\n   * then it gets transformed into the appropriate style property for JS access\n   * @param {string} p\n   * @return {string}\n   */\n  function styleProperty(p) {\n      (p == 'transform' && (p = features.transform)) ||\n        (/^transform-?[Oo]rigin$/.test(p) && (p = features.transform + 'Origin'))\n      return p ? camelize(p) : null\n  }\n\n  // this insert method is intense\n  function insert(target, host, fn, rev) {\n    var i = 0, self = host || this, r = []\n      // target nodes could be a css selector if it's a string and a selector engine is present\n      // otherwise, just use target\n      , nodes = query && typeof target == 'string' && target.charAt(0) != '<' ? query(target) : target\n    // normalize each node in case it's still a string and we need to create nodes on the fly\n    each(normalize(nodes), function (t, j) {\n      each(self, function (el) {\n        fn(t, r[i++] = j > 0 ? cloneNode(self, el) : el)\n      }, null, rev)\n    }, this, rev)\n    self.length = i\n    each(r, function (e) {\n      self[--i] = e\n    }, null, !rev)\n    return self\n  }\n\n\n  /**\n   * sets an element to an explicit x/y position on the page\n   * @param {Element} el\n   * @param {?number} x\n   * @param {?number} y\n   */\n  function xy(el, x, y) {\n    var $el = bonzo(el)\n      , style = $el.css('position')\n      , offset = $el.offset()\n      , rel = 'relative'\n      , isRel = style == rel\n      , delta = [parseInt($el.css('left'), 10), parseInt($el.css('top'), 10)]\n\n    if (style == 'static') {\n      $el.css('position', rel)\n      style = rel\n    }\n\n    isNaN(delta[0]) && (delta[0] = isRel ? 0 : el.offsetLeft)\n    isNaN(delta[1]) && (delta[1] = isRel ? 0 : el.offsetTop)\n\n    x != null && (el.style.left = x - offset.left + delta[0] + px)\n    y != null && (el.style.top = y - offset.top + delta[1] + px)\n\n  }\n\n  // classList support for class management\n  // altho to be fair, the api sucks because it won't accept multiple classes at once\n  if (features.classList) {\n    hasClass = function (el, c) {\n      return el.classList.contains(c)\n    }\n    addClass = function (el, c) {\n      el.classList.add(c)\n    }\n    removeClass = function (el, c) {\n      el.classList.remove(c)\n    }\n  }\n  else {\n    hasClass = function (el, c) {\n      return classReg(c).test(el.className)\n    }\n    addClass = function (el, c) {\n      el.className = (el.className + ' ' + c).trim()\n    }\n    removeClass = function (el, c) {\n      el.className = (el.className.replace(classReg(c), ' ')).trim()\n    }\n  }\n\n\n  /**\n   * this allows method calling for setting values\n   *\n   * @example\n   * bonzo(elements).css('color', function (el) {\n   *   return el.getAttribute('data-original-color')\n   * })\n   *\n   * @param {Element} el\n   * @param {function (Element)|string} v\n   * @return {string}\n   */\n  function setter(el, v) {\n    return typeof v == 'function' ? v.call(el, el) : v\n  }\n\n  function scroll(x, y, type) {\n    var el = this[0]\n    if (!el) return this\n    if (x == null && y == null) {\n      return (isBody(el) ? getWindowScroll() : { x: el.scrollLeft, y: el.scrollTop })[type]\n    }\n    if (isBody(el)) {\n      win.scrollTo(x, y)\n    } else {\n      x != null && (el.scrollLeft = x)\n      y != null && (el.scrollTop = y)\n    }\n    return this\n  }\n\n  /**\n   * @constructor\n   * @param {Array.<Element>|Element|Node|string} elements\n   */\n  function Bonzo(elements) {\n    this.length = 0\n    if (elements) {\n      elements = typeof elements !== 'string' &&\n        !elements.nodeType &&\n        typeof elements.length !== 'undefined' ?\n          elements :\n          [elements]\n      this.length = elements.length\n      for (var i = 0; i < elements.length; i++) this[i] = elements[i]\n    }\n  }\n\n  Bonzo.prototype = {\n\n      /**\n       * @param {number} index\n       * @return {Element|Node}\n       */\n      get: function (index) {\n        return this[index] || null\n      }\n\n      // itetators\n      /**\n       * @param {function(Element|Node)} fn\n       * @param {Object=} opt_scope\n       * @return {Bonzo}\n       */\n    , each: function (fn, opt_scope) {\n        return each(this, fn, opt_scope)\n      }\n\n      /**\n       * @param {Function} fn\n       * @param {Object=} opt_scope\n       * @return {Bonzo}\n       */\n    , deepEach: function (fn, opt_scope) {\n        return deepEach(this, fn, opt_scope)\n      }\n\n\n      /**\n       * @param {Function} fn\n       * @param {Function=} opt_reject\n       * @return {Array}\n       */\n    , map: function (fn, opt_reject) {\n        var m = [], n, i\n        for (i = 0; i < this.length; i++) {\n          n = fn.call(this, this[i], i)\n          opt_reject ? (opt_reject(n) && m.push(n)) : m.push(n)\n        }\n        return m\n      }\n\n    // text and html inserters!\n\n    /**\n     * @param {string} h the HTML to insert\n     * @param {boolean=} opt_text whether to set or get text content\n     * @return {Bonzo|string}\n     */\n    , html: function (h, opt_text) {\n        var method = opt_text\n              ? 'textContent'\n              : 'innerHTML'\n          , that = this\n          , append = function (el, i) {\n              each(normalize(h, that, i), function (node) {\n                el.appendChild(node)\n              })\n            }\n          , updateElement = function (el, i) {\n              try {\n                if (opt_text || (typeof h == 'string' && !specialTags.test(el.tagName))) {\n                  return el[method] = h\n                }\n              } catch (e) {}\n              append(el, i)\n            }\n        return typeof h != 'undefined'\n          ? this.empty().each(updateElement)\n          : this[0] ? this[0][method] : ''\n      }\n\n      /**\n       * @param {string=} opt_text the text to set, otherwise this is a getter\n       * @return {Bonzo|string}\n       */\n    , text: function (opt_text) {\n        return this.html(opt_text, true)\n      }\n\n      // more related insertion methods\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , append: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el.appendChild(i)\n          })\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , prepend: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          var first = el.firstChild\n          each(normalize(node, that, i), function (i) {\n            el.insertBefore(i, first)\n          })\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , appendTo: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          t.appendChild(el)\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , prependTo: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          t.insertBefore(el, t.firstChild)\n        }, 1)\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , before: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el[parentNode].insertBefore(i, el)\n          })\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , after: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el[parentNode].insertBefore(i, el.nextSibling)\n          }, null, 1)\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , insertBefore: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          t[parentNode].insertBefore(el, t)\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , insertAfter: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          var sibling = t.nextSibling\n          sibling ?\n            t[parentNode].insertBefore(el, sibling) :\n            t[parentNode].appendChild(el)\n        }, 1)\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , replaceWith: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el[parentNode] && el[parentNode].replaceChild(i, el)\n          })\n        })\n      }\n\n      /**\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , clone: function (opt_host) {\n        var ret = [] // don't change original array\n          , l, i\n        for (i = 0, l = this.length; i < l; i++) ret[i] = cloneNode(opt_host || this, this[i])\n        return bonzo(ret)\n      }\n\n      // class management\n\n      /**\n       * @param {string} c\n       * @return {Bonzo}\n       */\n    , addClass: function (c) {\n        c = toString.call(c).split(whitespaceRegex)\n        return this.each(function (el) {\n          // we `each` here so you can do $el.addClass('foo bar')\n          each(c, function (c) {\n            if (c && !hasClass(el, setter(el, c)))\n              addClass(el, setter(el, c))\n          })\n        })\n      }\n\n\n      /**\n       * @param {string} c\n       * @return {Bonzo}\n       */\n    , removeClass: function (c) {\n        c = toString.call(c).split(whitespaceRegex)\n        return this.each(function (el) {\n          each(c, function (c) {\n            if (c && hasClass(el, setter(el, c)))\n              removeClass(el, setter(el, c))\n          })\n        })\n      }\n\n\n      /**\n       * @param {string} c\n       * @return {boolean}\n       */\n    , hasClass: function (c) {\n        c = toString.call(c).split(whitespaceRegex)\n        return some(this, function (el) {\n          return some(c, function (c) {\n            return c && hasClass(el, c)\n          })\n        })\n      }\n\n\n      /**\n       * @param {string} c classname to toggle\n       * @param {boolean=} opt_condition whether to add or remove the class straight away\n       * @return {Bonzo}\n       */\n    , toggleClass: function (c, opt_condition) {\n        c = toString.call(c).split(whitespaceRegex)\n        return this.each(function (el) {\n          each(c, function (c) {\n            if (c) {\n              typeof opt_condition !== 'undefined' ?\n                opt_condition ? !hasClass(el, c) && addClass(el, c) : removeClass(el, c) :\n                hasClass(el, c) ? removeClass(el, c) : addClass(el, c)\n            }\n          })\n        })\n      }\n\n      // display togglers\n\n      /**\n       * @param {string=} opt_type useful to set back to anything other than an empty string\n       * @return {Bonzo}\n       */\n    , show: function (opt_type) {\n        opt_type = typeof opt_type == 'string' ? opt_type : ''\n        return this.each(function (el) {\n          el.style.display = opt_type\n        })\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , hide: function () {\n        return this.each(function (el) {\n          el.style.display = 'none'\n        })\n      }\n\n\n      /**\n       * @param {Function=} opt_callback\n       * @param {string=} opt_type\n       * @return {Bonzo}\n       */\n    , toggle: function (opt_callback, opt_type) {\n        opt_type = typeof opt_type == 'string' ? opt_type : '';\n        typeof opt_callback != 'function' && (opt_callback = null)\n        return this.each(function (el) {\n          el.style.display = (el.offsetWidth || el.offsetHeight) ? 'none' : opt_type;\n          opt_callback && opt_callback.call(el)\n        })\n      }\n\n\n      // DOM Walkers & getters\n\n      /**\n       * @return {Element|Node}\n       */\n    , first: function () {\n        return bonzo(this.length ? this[0] : [])\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , last: function () {\n        return bonzo(this.length ? this[this.length - 1] : [])\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , next: function () {\n        return this.related('nextSibling')\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , previous: function () {\n        return this.related('previousSibling')\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , parent: function() {\n        return this.related(parentNode)\n      }\n\n\n      /**\n       * @private\n       * @param {string} method the directional DOM method\n       * @return {Element|Node}\n       */\n    , related: function (method) {\n        return bonzo(this.map(\n          function (el) {\n            el = el[method]\n            while (el && el.nodeType !== 1) {\n              el = el[method]\n            }\n            return el || 0\n          },\n          function (el) {\n            return el\n          }\n        ))\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , focus: function () {\n        this.length && this[0].focus()\n        return this\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , blur: function () {\n        this.length && this[0].blur()\n        return this\n      }\n\n      // style getter setter & related methods\n\n      /**\n       * @param {Object|string} o\n       * @param {string=} opt_v\n       * @return {Bonzo|string}\n       */\n    , css: function (o, opt_v) {\n        var p, iter = o\n        // is this a request for just getting a style?\n        if (opt_v === undefined && typeof o == 'string') {\n          // repurpose 'v'\n          opt_v = this[0]\n          if (!opt_v) return null\n          if (opt_v === doc || opt_v === win) {\n            p = (opt_v === doc) ? bonzo.doc() : bonzo.viewport()\n            return o == 'width' ? p.width : o == 'height' ? p.height : ''\n          }\n          return (o = styleProperty(o)) ? getStyle(opt_v, o) : null\n        }\n\n        if (typeof o == 'string') {\n          iter = {}\n          iter[o] = opt_v\n        }\n\n        function fn(el, p, v) {\n          for (var k in iter) {\n            if (iter.hasOwnProperty(k)) {\n              v = iter[k];\n              // change \"5\" to \"5px\" - unless you're line-height, which is allowed\n              (p = styleProperty(k)) && digit.test(v) && !(p in unitless) && (v += px)\n              try { el.style[p] = setter(el, v) } catch(e) {}\n            }\n          }\n        }\n        return this.each(fn)\n      }\n\n\n      /**\n       * @param {number=} opt_x\n       * @param {number=} opt_y\n       * @return {Bonzo|number}\n       */\n    , offset: function (opt_x, opt_y) {\n        if (opt_x && typeof opt_x == 'object' && (typeof opt_x.top == 'number' || typeof opt_x.left == 'number')) {\n          return this.each(function (el) {\n            xy(el, opt_x.left, opt_x.top)\n          })\n        } else if (typeof opt_x == 'number' || typeof opt_y == 'number') {\n          return this.each(function (el) {\n            xy(el, opt_x, opt_y)\n          })\n        }\n        if (!this[0]) return {\n            top: 0\n          , left: 0\n          , height: 0\n          , width: 0\n        }\n        var el = this[0]\n          , de = el.ownerDocument.documentElement\n          , bcr = el.getBoundingClientRect()\n          , scroll = getWindowScroll()\n          , width = el.offsetWidth\n          , height = el.offsetHeight\n          , top = bcr.top + scroll.y - Math.max(0, de && de.clientTop, doc.body.clientTop)\n          , left = bcr.left + scroll.x - Math.max(0, de && de.clientLeft, doc.body.clientLeft)\n\n        return {\n            top: top\n          , left: left\n          , height: height\n          , width: width\n        }\n      }\n\n\n      /**\n       * @return {number}\n       */\n    , dim: function () {\n        if (!this.length) return { height: 0, width: 0 }\n        var el = this[0]\n          , de = el.nodeType == 9 && el.documentElement // document\n          , orig = !de && !!el.style && !el.offsetWidth && !el.offsetHeight ?\n             // el isn't visible, can't be measured properly, so fix that\n             function (t) {\n               var s = {\n                   position: el.style.position || ''\n                 , visibility: el.style.visibility || ''\n                 , display: el.style.display || ''\n               }\n               t.first().css({\n                   position: 'absolute'\n                 , visibility: 'hidden'\n                 , display: 'block'\n               })\n               return s\n            }(this) : null\n          , width = de\n              ? Math.max(el.body.scrollWidth, el.body.offsetWidth, de.scrollWidth, de.offsetWidth, de.clientWidth)\n              : el.offsetWidth\n          , height = de\n              ? Math.max(el.body.scrollHeight, el.body.offsetHeight, de.scrollHeight, de.offsetHeight, de.clientHeight)\n              : el.offsetHeight\n\n        orig && this.first().css(orig)\n        return {\n            height: height\n          , width: width\n        }\n      }\n\n      // attributes are hard. go shopping\n\n      /**\n       * @param {string} k an attribute to get or set\n       * @param {string=} opt_v the value to set\n       * @return {Bonzo|string}\n       */\n    , attr: function (k, opt_v) {\n        var el = this[0]\n          , n\n\n        if (typeof k != 'string' && !(k instanceof String)) {\n          for (n in k) {\n            k.hasOwnProperty(n) && this.attr(n, k[n])\n          }\n          return this\n        }\n\n        return typeof opt_v == 'undefined' ?\n          !el ? null : specialAttributes.test(k) ?\n            stateAttributes.test(k) && typeof el[k] == 'string' ?\n              true : el[k] :  el[getAttribute](k) :\n          this.each(function (el) {\n            specialAttributes.test(k) ? (el[k] = setter(el, opt_v)) : el[setAttribute](k, setter(el, opt_v))\n          })\n      }\n\n\n      /**\n       * @param {string} k\n       * @return {Bonzo}\n       */\n    , removeAttr: function (k) {\n        return this.each(function (el) {\n          stateAttributes.test(k) ? (el[k] = false) : el.removeAttribute(k)\n        })\n      }\n\n\n      /**\n       * @param {string=} opt_s\n       * @return {Bonzo|string}\n       */\n    , val: function (s) {\n        return (typeof s == 'string' || typeof s == 'number') ?\n          this.attr('value', s) :\n          this.length ? this[0].value : null\n      }\n\n      // use with care and knowledge. this data() method uses data attributes on the DOM nodes\n      // to do this differently costs a lot more code. c'est la vie\n      /**\n       * @param {string|Object=} opt_k the key for which to get or set data\n       * @param {Object=} opt_v\n       * @return {Bonzo|Object}\n       */\n    , data: function (opt_k, opt_v) {\n        var el = this[0], o, m\n        if (typeof opt_v === 'undefined') {\n          if (!el) return null\n          o = data(el)\n          if (typeof opt_k === 'undefined') {\n            each(el.attributes, function (a) {\n              (m = ('' + a.name).match(dattr)) && (o[camelize(m[1])] = dataValue(a.value))\n            })\n            return o\n          } else {\n            if (typeof o[opt_k] === 'undefined')\n              o[opt_k] = dataValue(this.attr('data-' + decamelize(opt_k)))\n            return o[opt_k]\n          }\n        } else {\n          return this.each(function (el) { data(el)[opt_k] = opt_v })\n        }\n      }\n\n      // DOM detachment & related\n\n      /**\n       * @return {Bonzo}\n       */\n    , remove: function () {\n        this.deepEach(clearData)\n        return this.detach()\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , empty: function () {\n        return this.each(function (el) {\n          deepEach(el.childNodes, clearData)\n\n          while (el.firstChild) {\n            el.removeChild(el.firstChild)\n          }\n        })\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , detach: function () {\n        return this.each(function (el) {\n          el[parentNode] && el[parentNode].removeChild(el)\n        })\n      }\n\n      // who uses a mouse anyway? oh right.\n\n      /**\n       * @param {number} y\n       */\n    , scrollTop: function (y) {\n        return scroll.call(this, null, y, 'y')\n      }\n\n\n      /**\n       * @param {number} x\n       */\n    , scrollLeft: function (x) {\n        return scroll.call(this, x, null, 'x')\n      }\n\n  }\n\n\n  function cloneNode(host, el) {\n    var c = el.cloneNode(true)\n      , cloneElems\n      , elElems\n      , i\n\n    // check for existence of an event cloner\n    // preferably https://github.com/fat/bean\n    // otherwise Bonzo won't do this for you\n    if (host.$ && typeof host.cloneEvents == 'function') {\n      host.$(c).cloneEvents(el)\n\n      // clone events from every child node\n      cloneElems = host.$(c).find('*')\n      elElems = host.$(el).find('*')\n\n      for (i = 0; i < elElems.length; i++)\n        host.$(cloneElems[i]).cloneEvents(elElems[i])\n    }\n    return c\n  }\n\n  function isBody(element) {\n    return element === win || (/^(?:body|html)$/i).test(element.tagName)\n  }\n\n  function getWindowScroll() {\n    return { x: win.pageXOffset || html.scrollLeft, y: win.pageYOffset || html.scrollTop }\n  }\n\n  function createScriptFromHtml(html) {\n    var scriptEl = document.createElement('script')\n      , matches = html.match(simpleScriptTagRe)\n    scriptEl.src = matches[1]\n    return scriptEl\n  }\n\n  /**\n   * @param {Array.<Element>|Element|Node|string} els\n   * @return {Bonzo}\n   */\n  function bonzo(els) {\n    return new Bonzo(els)\n  }\n\n  bonzo.setQueryEngine = function (q) {\n    query = q;\n    delete bonzo.setQueryEngine\n  }\n\n  bonzo.aug = function (o, target) {\n    // for those standalone bonzo users. this love is for you.\n    for (var k in o) {\n      o.hasOwnProperty(k) && ((target || Bonzo.prototype)[k] = o[k])\n    }\n  }\n\n  bonzo.create = function (node) {\n    // hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n    return typeof node == 'string' && node !== '' ?\n      function () {\n        if (simpleScriptTagRe.test(node)) return [createScriptFromHtml(node)]\n        var tag = node.match(/^\\s*<([^\\s>]+)/)\n          , el = doc.createElement('div')\n          , els = []\n          , p = tag ? tagMap[tag[1].toLowerCase()] : null\n          , dep = p ? p[2] + 1 : 1\n          , ns = p && p[3]\n          , pn = parentNode\n\n        el.innerHTML = p ? (p[0] + node + p[1]) : node\n        while (dep--) el = el.firstChild\n        // for IE NoScope, we may insert cruft at the begining just to get it to work\n        if (ns && el && el.nodeType !== 1) el = el.nextSibling\n        do {\n          if (!tag || el.nodeType == 1) {\n            els.push(el)\n          }\n        } while (el = el.nextSibling)\n        // IE < 9 gives us a parentNode which messes up insert() check for cloning\n        // `dep` > 1 can also cause problems with the insert() check (must do this last)\n        each(els, function(el) { el[pn] && el[pn].removeChild(el) })\n        return els\n      }() : isNode(node) ? [node.cloneNode(true)] : []\n  }\n\n  bonzo.doc = function () {\n    var vp = bonzo.viewport()\n    return {\n        width: Math.max(doc.body.scrollWidth, html.scrollWidth, vp.width)\n      , height: Math.max(doc.body.scrollHeight, html.scrollHeight, vp.height)\n    }\n  }\n\n  bonzo.firstChild = function (el) {\n    for (var c = el.childNodes, i = 0, j = (c && c.length) || 0, e; i < j; i++) {\n      if (c[i].nodeType === 1) e = c[j = i]\n    }\n    return e\n  }\n\n  bonzo.viewport = function () {\n    return {\n        width: win.innerWidth\n      , height: win.innerHeight\n    }\n  }\n\n  bonzo.isAncestor = 'compareDocumentPosition' in html ?\n    function (container, element) {\n      return (container.compareDocumentPosition(element) & 16) == 16\n    } :\n    function (container, element) {\n      return container !== element && container.contains(element);\n    }\n\n  return bonzo\n}); // the only line we care about using a semi-colon. placed here for concatenation tools\n","/home/travis/build/npmtest/node-npmtest-bonzo/node_modules/bonzo/src/copyright.js":"/*!\n  * Bonzo: DOM Utility (c) Dustin Diaz 2012\n  * https://github.com/ded/bonzo\n  * License MIT\n  */","/home/travis/build/npmtest/node-npmtest-bonzo/node_modules/bonzo/src/ender.js":"(function ($) {\n\n  var b = require('bonzo')\n  b.setQueryEngine($)\n  $.ender(b)\n  $.ender(b(), true)\n  $.ender({\n    create: function (node) {\n      return $(b.create(node))\n    }\n  })\n\n  $.id = function (id) {\n    return $([document.getElementById(id)])\n  }\n\n  function indexOf(ar, val) {\n    for (var i = 0; i < ar.length; i++) if (ar[i] === val) return i\n    return -1\n  }\n\n  function uniq(ar) {\n    var r = [], i = 0, j = 0, k, item, inIt\n    for (; item = ar[i]; ++i) {\n      inIt = false\n      for (k = 0; k < r.length; ++k) {\n        if (r[k] === item) {\n          inIt = true; break\n        }\n      }\n      if (!inIt) r[j++] = item\n    }\n    return r\n  }\n\n  $.ender({\n    parents: function (selector, closest) {\n      if (!this.length) return this\n      if (!selector) selector = '*'\n      var collection = $(selector), j, k, p, r = []\n      for (j = 0, k = this.length; j < k; j++) {\n        p = this[j]\n        while (p = p.parentNode) {\n          if (~indexOf(collection, p)) {\n            r.push(p)\n            if (closest) break;\n          }\n        }\n      }\n      return $(uniq(r))\n    }\n\n  , parent: function() {\n      return $(uniq(b(this).parent()))\n    }\n\n  , closest: function (selector) {\n      return this.parents(selector, true)\n    }\n\n  , first: function () {\n      return $(this.length ? this[0] : this)\n    }\n\n  , last: function () {\n      return $(this.length ? this[this.length - 1] : [])\n    }\n\n  , next: function () {\n      return $(b(this).next())\n    }\n\n  , previous: function () {\n      return $(b(this).previous())\n    }\n\n  , related: function (t) {\n      return $(b(this).related(t))\n    }\n\n  , appendTo: function (t) {\n      return b(this.selector).appendTo(t, this)\n    }\n\n  , prependTo: function (t) {\n      return b(this.selector).prependTo(t, this)\n    }\n\n  , insertAfter: function (t) {\n      return b(this.selector).insertAfter(t, this)\n    }\n\n  , insertBefore: function (t) {\n      return b(this.selector).insertBefore(t, this)\n    }\n\n  , clone: function () {\n      return $(b(this).clone(this))\n    }\n\n  , siblings: function () {\n      var i, l, p, r = []\n      for (i = 0, l = this.length; i < l; i++) {\n        p = this[i]\n        while (p = p.previousSibling) p.nodeType == 1 && r.push(p)\n        p = this[i]\n        while (p = p.nextSibling) p.nodeType == 1 && r.push(p)\n      }\n      return $(r)\n    }\n\n  , children: function () {\n      var i, l, el, r = []\n      for (i = 0, l = this.length; i < l; i++) {\n        if (!(el = b.firstChild(this[i]))) continue;\n        r.push(el)\n        while (el = el.nextSibling) el.nodeType == 1 && r.push(el)\n      }\n      return $(uniq(r))\n    }\n\n  , height: function (v) {\n      return dimension.call(this, 'height', v)\n    }\n\n  , width: function (v) {\n      return dimension.call(this, 'width', v)\n    }\n  }, true)\n\n  /**\n   * @param {string} type either width or height\n   * @param {number=} opt_v becomes a setter instead of a getter\n   * @return {number}\n   */\n  function dimension(type, opt_v) {\n    return typeof opt_v == 'undefined'\n      ? b(this).dim()[type]\n      : this.css(type, opt_v)\n  }\n}(ender));"}